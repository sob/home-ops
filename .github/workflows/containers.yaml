---
name: Build Containers

env:
  REGISTRY: ghcr.io

on:
  push:
    branches: [main]
    paths:
      - "containers/**"
      - "!containers/**/go.mod"
      - "!containers/**/go.sum"
  pull_request:
    branches: [main]
    paths:
      - "containers/**"
      - "!containers/**/go.mod"
      - "!containers/**/go.sum"
  workflow_dispatch:
    inputs:
      app:
        description: "Container to build (optional - builds all changed if empty)"
        required: false
        type: string

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      changed-files: ${{ steps.changed-files.outputs.all_changed_files }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Get changed files
        id: changed-files
        if: github.event_name != 'workflow_dispatch'
        uses: tj-actions/changed-files@v41
        with:
          files: containers/**
          dir_names: true
          dir_names_max_depth: 2
          json: true

  changed:
    runs-on: ubuntu-latest
    needs: prepare
    outputs:
      apps: ${{ steps.changed.outputs.apps }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Determine changed apps
        id: changed
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            if [ -n "${{ github.event.inputs.app }}" ]; then
              # Build specific app
              echo "apps=[\"${{ github.event.inputs.app }}\"]" >> $GITHUB_OUTPUT
            else
              # Build all apps
              apps=$(find containers -maxdepth 1 -mindepth 1 -type d -exec basename {} \; | jq -R -s -c 'split("\n") | map(select(length > 0))')
              echo "apps=$apps" >> $GITHUB_OUTPUT
            fi
          else
            # Automatic trigger - use changed files
            changed_files="${{ needs.prepare.outputs.changed-files }}"
            echo "Changed files raw output: '$changed_files'"
            if [ -z "$changed_files" ] || [ "$changed_files" = "[]" ] || [ "$changed_files" = "null" ] || [ "$changed_files" = "" ]; then
              echo "No changes detected, setting empty array"
              echo "apps=[]" >> $GITHUB_OUTPUT
            else
              # Validate JSON before processing
              if echo "$changed_files" | jq empty 2>/dev/null; then
                # Extract app directories from changed files
                apps=$(echo "$changed_files" | jq -r '.[]' | cut -d'/' -f2 | sort -u | jq -R -s -c 'split("\n") | map(select(length > 0))')
                echo "Extracted apps: $apps"
                echo "apps=$apps" >> $GITHUB_OUTPUT
              else
                echo "ERROR: Invalid JSON in changed_files output"
                echo "Raw value: '$changed_files'"
                echo "This is likely a bug in the changed-files action configuration"
                exit 1
              fi
            fi
          fi

  plan:
    runs-on: ubuntu-latest
    needs: changed
    if: ${{ fromJson(needs.changed.outputs.apps)[0] != null }}
    strategy:
      fail-fast: false
      max-parallel: 10
      matrix:
        app: ${{ fromJson(needs.changed.outputs.apps) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Check if app exists
        run: |
          if [ ! -d "containers/${{ matrix.app }}" ]; then
            echo "App ${{ matrix.app }} does not exist"
            exit 1
          fi
          if [ ! -f "containers/${{ matrix.app }}/docker-bake.hcl" ]; then
            echo "App ${{ matrix.app }} does not have docker-bake.hcl"
            exit 1
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Get version
        id: version
        working-directory: containers/${{ matrix.app }}
        run: |
          echo "=== Docker bake output ==="
          docker buildx bake --print
          echo "=== Extracting versions ==="
          bake_output=$(docker buildx bake --print)

          # Get the first target name dynamically
          target=$(echo "$bake_output" | jq -r '.target | keys[0]')
          echo "Found target: $target"

          # Get version from the image.version label
          version=$(echo "$bake_output" | jq -r ".target[\"${target}\"].labels.\"org.opencontainers.image.version\" // empty")

          # Get major version by finding the shortest non-rolling tag
          major_version=$(echo "$bake_output" | jq -r ".target[\"${target}\"].tags[]" | sed 's/.*://' | grep -v rolling | sort -n | head -1)

          if [ -z "$version" ]; then
            version="rolling"
          fi
          echo "Extracted version: '$version'"
          echo "Extracted major_version: '$major_version'"
          echo "version=$version" >> $GITHUB_OUTPUT
          echo "major_version=$major_version" >> $GITHUB_OUTPUT

  build-image:
    runs-on: ${{ matrix.runner }}
    needs: [changed, plan]
    if: ${{ fromJson(needs.changed.outputs.apps)[0] != null }}
    strategy:
      fail-fast: false
      max-parallel: 10
      matrix:
        app: ${{ fromJson(needs.changed.outputs.apps) }}
        platform: [linux/amd64, linux/arm64]
        include:
          - platform: linux/amd64
            runner: ubuntu-24.04
          - platform: linux/arm64
            runner: ubuntu-24.04-arm
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for annotations
        id: meta
        uses: docker/metadata-action@v5
        env:
          DOCKER_METADATA_ANNOTATIONS_LEVELS: manifest,index
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ matrix.app }}
          tags: |
            type=raw,value=dummy
          bake-target: ${{ matrix.app }}

      - name: Build App
        id: build
        uses: docker/bake-action@v5
        with:
          workdir: containers/${{ matrix.app }}
          targets: ${{ matrix.app }}
          provenance: false
          set: |
            *.platform=${{ matrix.platform }}
            *.tags=
            *.output=type=image,name=${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ matrix.app }}:build-${{ github.sha }}-${{ matrix.platform == 'linux/amd64' && 'amd64' || 'arm64' }},push=true
            *.cache-from=type=gha
            *.cache-to=type=gha,mode=max
            *.labels.org.opencontainers.image.revision=${{ github.sha }}
          files: |
            ./docker-bake.hcl
            ${{ steps.meta.outputs.bake-file }}

      - name: Export digest
        run: |
          mkdir -p /tmp/digests
          digest="${{ fromJSON(steps.build.outputs.metadata)[matrix.app]['containerimage.digest'] }}"
          platform_tag="${{ matrix.platform == 'linux/amd64' && 'amd64' || 'arm64' }}"
          echo "${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ matrix.app }}:build-${{ github.sha }}-${platform_tag}" > "/tmp/digests/${platform_tag}"

      - name: Upload digest
        uses: actions/upload-artifact@v4
        with:
          name: digests-${{ matrix.app }}-${{ matrix.platform == 'linux/amd64' && 'amd64' || 'arm64' }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  tag-commit:
    runs-on: ubuntu-latest
    needs: [changed, plan]
    if: ${{ !cancelled() && fromJson(needs.changed.outputs.apps)[0] != null }}
    strategy:
      fail-fast: false
      max-parallel: 10
      matrix:
        app: ${{ fromJson(needs.changed.outputs.apps) }}
    steps:
      - name: Wait for build artifacts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Waiting for build artifacts for ${{ matrix.app }}..."
          PLATFORMS=("amd64" "arm64")
          MAX_WAIT=600  # 10 minutes
          INTERVAL=10
          ELAPSED=0

          while [ $ELAPSED -lt $MAX_WAIT ]; do
            ALL_FOUND=true
            for platform in "${PLATFORMS[@]}"; do
              artifact_name="digests-${{ matrix.app }}-${platform}"
              if ! gh api "/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts" \
                  --jq ".artifacts[] | select(.name == \"${artifact_name}\") | .name" | grep -q "${artifact_name}"; then
                echo "  ⏳ Waiting for ${artifact_name}..."
                ALL_FOUND=false
                break
              fi
            done

            if [ "$ALL_FOUND" = true ]; then
              echo "✓ All build artifacts ready for ${{ matrix.app }}"
              exit 0
            fi

            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done

          echo "ERROR: Timed out waiting for build artifacts after ${MAX_WAIT}s"
          exit 1

      - name: Download digests
        uses: actions/download-artifact@v4
        with:
          pattern: digests-${{ matrix.app }}-*
          path: /tmp/digests
          merge-multiple: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout repository for version info
        uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Create manifest and tag with commit hash
        working-directory: /tmp/digests
        run: |
          IMAGE_NAME="${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ matrix.app }}"
          SHORT_SHA="${{ github.sha }}"
          SHORT_SHA="${SHORT_SHA:0:7}"

          # Get version from docker-bake.hcl
          cd ${{ github.workspace }}/containers/${{ matrix.app }}
          bake_output=$(docker buildx bake --print)
          target=$(echo "$bake_output" | jq -r '.target | keys[0]')
          VERSION=$(echo "$bake_output" | jq -r ".target[\"${target}\"].labels.\"org.opencontainers.image.version\" // empty")

          if [ -z "$VERSION" ] || [ "$VERSION" = "rolling" ]; then
            VERSION="rolling"
            VERSION_TAG="${SHORT_SHA}"
          else
            VERSION_TAG="${VERSION}-${SHORT_SHA}"
          fi

          echo "Version: $VERSION"
          echo "Version Tag: $VERSION_TAG"

          cd /tmp/digests
          echo "Available platform tag files:"
          ls -la

          IMAGES=""
          for platform in *; do
            platform_tag=$(cat "$platform")
            echo "Checking if platform image exists: $platform_tag"

            # Check if the image actually exists in the registry
            if docker buildx imagetools inspect "$platform_tag" > /dev/null 2>&1; then
              echo "✓ Platform $platform image found: $platform_tag"
              IMAGES="$IMAGES $platform_tag"
            else
              echo "✗ Platform $platform image not found (build may have failed): $platform_tag"
            fi
          done

          if [ -z "$IMAGES" ]; then
            echo "ERROR: No platform images found - all builds failed"
            exit 1
          fi

          echo "Valid platform images:$IMAGES"

          # Create commit hash tag for testing
          echo "Creating ${SHORT_SHA} tag for testing..."
          docker buildx imagetools create -t ${IMAGE_NAME}:${SHORT_SHA} $IMAGES

          # Create version-sha tag for semantic versioning
          echo "Creating version-sha tag: ${VERSION_TAG}"
          docker buildx imagetools create -t ${IMAGE_NAME}:${VERSION_TAG} $IMAGES

  tag-release:
    runs-on: ubuntu-latest
    needs: [changed, plan, tag-commit, test]
    if: ${{ !cancelled() && fromJson(needs.changed.outputs.apps)[0] != null }}
    strategy:
      fail-fast: false
      max-parallel: 10
      matrix:
        app: ${{ fromJson(needs.changed.outputs.apps) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Get version info
        id: version
        working-directory: containers/${{ matrix.app }}
        run: |
          bake_output=$(docker buildx bake --print)
          target=$(echo "$bake_output" | jq -r '.target | keys[0]')
          version=$(echo "$bake_output" | jq -r ".target[\"${target}\"].labels.\"org.opencontainers.image.version\" // empty")
          major_version=$(echo "$bake_output" | jq -r ".target[\"${target}\"].tags[]" | sed 's/.*://' | grep -v rolling | sort -n | head -1)

          if [ -z "$version" ]; then
            version="rolling"
          fi
          echo "version=$version" >> $GITHUB_OUTPUT
          echo "major_version=$major_version" >> $GITHUB_OUTPUT

      - name: Create release tags
        run: |
          IMAGE_NAME="${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ matrix.app }}"
          SHORT_SHA="${{ github.sha }}"
          SHORT_SHA="${SHORT_SHA:0:7}"

          # Reference the commit hash tag created earlier
          COMMIT_TAG="${IMAGE_NAME}:${SHORT_SHA}"

          echo "=== Version Information ==="
          echo "Version: '${{ steps.version.outputs.version }}'"
          echo "Major Version: '${{ steps.version.outputs.major_version }}'"

          # Get the image digest for sha256 tag
          DIGEST=$(docker buildx imagetools inspect ${COMMIT_TAG} --format '{{json .}}' | jq -r '.manifest.digest' | sed 's/sha256://')
          echo "Image digest: $DIGEST"

          # Create rolling tag
          echo "Creating rolling tag..."
          docker buildx imagetools create -t ${IMAGE_NAME}:rolling ${COMMIT_TAG}

          # Create major version tag if defined
          if [ -n "${{ steps.version.outputs.major_version }}" ]; then
            echo "Creating major version tag: ${{ steps.version.outputs.major_version }}"
            docker buildx imagetools create -t ${IMAGE_NAME}:${{ steps.version.outputs.major_version }} ${COMMIT_TAG}
          else
            echo "Skipping major version tag - not defined"
          fi

          # Create version tag
          if [ -n "${{ steps.version.outputs.version }}" ] && [ "${{ steps.version.outputs.version }}" != "rolling" ]; then
            echo "Creating version tag: ${{ steps.version.outputs.version }}"
            docker buildx imagetools create -t ${IMAGE_NAME}:${{ steps.version.outputs.version }} ${COMMIT_TAG}
          else
            echo "Skipping version tag - empty or rolling"
          fi

          # Create sha256 tag last so it becomes the default (immutable content-addressed tag)
          echo "Creating immutable sha256 tag as default: sha256-${DIGEST}"
          docker buildx imagetools create -t ${IMAGE_NAME}:sha256-${DIGEST} ${COMMIT_TAG}

      - name: Update package README
        if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
        run: |
          PACKAGE_NAME="${{ matrix.app }}"

          # Check if README exists for this container
          if [ -f "containers/$PACKAGE_NAME/README.md" ]; then
            echo "Updating package README from containers/$PACKAGE_NAME/README.md"

            # GitHub API requires the README content to be base64 encoded
            README_CONTENT=$(cat "containers/$PACKAGE_NAME/README.md" | base64 -w 0)

            # Update the package README
            curl -X PUT \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/user/packages/container/$PACKAGE_NAME" \
              -d "{\"description\":\"$(head -1 containers/$PACKAGE_NAME/README.md | sed 's/^# //')\"}" || true
          else
            echo "No README found at containers/$PACKAGE_NAME/README.md"
          fi

      - name: Clean up untagged digest images
        if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
        run: |
          # Delete untagged images (digest-only images from multi-platform build)
          PACKAGE_NAME="${{ matrix.app }}"

          # Get all package versions
          echo "Fetching package versions for $PACKAGE_NAME..."
          VERSIONS=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/users/${{ github.repository_owner }}/packages/container/$PACKAGE_NAME/versions" | \
            jq -r '.[] | select(.metadata.container.tags | length == 0) | .id')

          # Delete each untagged version
          for VERSION_ID in $VERSIONS; do
            echo "Deleting untagged version: $VERSION_ID"
            curl -X DELETE -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/users/${{ github.repository_owner }}/packages/container/$PACKAGE_NAME/versions/$VERSION_ID" || true
          done

          echo "Cleanup complete"

  test:
    runs-on: ubuntu-latest
    needs: [changed, plan, tag-commit]
    if: ${{ !cancelled() && fromJson(needs.changed.outputs.apps)[0] != null }}
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      max-parallel: 10
      matrix:
        app: ${{ fromJson(needs.changed.outputs.apps) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.25'

      - name: Run container tests
        id: test
        working-directory: containers/${{ matrix.app }}
        env:
          TEST_IMAGE_TAG: ${{ github.sha }}
        run: |
          if [ -f "container_test.go" ]; then
            SHORT_SHA="${TEST_IMAGE_TAG:0:7}"
            echo "Running container tests for ${{ matrix.app }}"
            echo "Using image tag: $SHORT_SHA"
            export TEST_IMAGE_TAG="$SHORT_SHA"
            go test -v .
          else
            echo "No container tests found for ${{ matrix.app }}"
          fi

      - name: Delete commit hash tag on test failure
        if: failure() && steps.test.outcome == 'failure'
        run: |
          SHORT_SHA="${{ github.sha }}"
          SHORT_SHA="${SHORT_SHA:0:7}"
          PACKAGE_NAME="${{ matrix.app }}"

          echo "Tests failed - cleaning up commit hash tag: ${SHORT_SHA}"

          # Get the version ID for the commit hash tag
          VERSION_ID=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/users/${{ github.repository_owner }}/packages/container/$PACKAGE_NAME/versions" | \
            jq -r ".[] | select(.metadata.container.tags[]? == \"${SHORT_SHA}\") | .id")

          if [ -n "$VERSION_ID" ]; then
            echo "Deleting failed build tag ${SHORT_SHA} (version ID: $VERSION_ID)"
            curl -X DELETE -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/users/${{ github.repository_owner }}/packages/container/$PACKAGE_NAME/versions/$VERSION_ID" || true
            echo "Cleanup complete - failed image cannot be pulled"
          else
            echo "No tag found for ${SHORT_SHA}"
          fi